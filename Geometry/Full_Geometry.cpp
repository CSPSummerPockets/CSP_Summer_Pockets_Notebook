const double EPS = 1e-9; //too small/big?????
struct PT{
    double x,y;
    double length() {return sqrt(x*x+y*y);}
    int normalize(){
    // normalize the vector to unit length; return -1 if the vector is 0
        double l = length();
        if(fabs(l)<EPS) return -1;
        x/=l; y/=l;
        return 0;
    }
    PT operator-(PT a){
        PT r;
        r.x=x-a.x; r.y=y-a.y;
        return r;
    }
    PT operator+(PT a){
        PT r;
        r.x=x+a.x; r.y=y+a.y;
        return r;
    }
    PT operator*(double sc){
        PT r;
        r.x=x*sc; r.y=y*sc;
        return r;
    }
};
bool operator<(const PT& a,const PT& b){
    if(fabs(a.x-b.x)<EPS) return a.y<b.y;
    return a.x<b.x;
}
double dist(PT& a, PT& b){
// the distance between two points
    return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
double dot(PT& a, PT& b){
// the inner product of two vectors
    return(a.x*b.x+a.y*b.y);
}
int sideSign(PT& p1,PT& p2,PT& p3){
// which side is p3 to the line p1->p2? returns: 1 left, 0 on, -1 right
    double sg = (p1.x-p3.x)*(p2.y-p3.y)-(p1.y - p3.y)*(p2.x-p3.x);
    if(fabs(sg)<EPS) return 0;
    if(sg>0)return 1;
    return -1;
}
int intersection( PT p1, PT p2, PT p3, PT p4, PT &r ){
// two lines given by p1->p2, p3->p4 r is the intersection point
// return -1 if two lines are parallel
    double d = (p4.y - p3.y)*(p2.x-p1.x) - (p4.x - p3.x)*(p2.y - p1.y);
    if( fabs( d ) < EPS ) return -1;
    // might need to do something special!!!
    double ua, ub;
    ua = (p4.x - p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
    ua /= d;
    r = p1 + (p2-p1)*ua;
    return 0;
}
double trap(PT a, PT b){
    return (0.5*(b.x - a.x)*(b.y + a.y));
}
double area(vector<PT> &vin){
// Area of a simple polygon, not neccessary convex
    int n = vin.size();
    double ret = 0.0;
    for(int i = 0; i < n; i++)
    ret += trap(vin[i], vin[(i+1)%n]);
    return fabs(ret);
}
double peri(vector<PT> &vin){
// Perimeter of a simple polygon, not neccessary convex
    int n = vin.size();
    double ret = 0.0;
    for(int i = 0; i < n; i++)
    ret += dist(vin[i], vin[(i+1)%n]);
    return ret;
}
double triarea(PT a, PT b, PT c){
    return fabs(trap(a,b)+trap(b,c)+trap(c,a));
}
double height(PT a, PT b, PT c){
// height from a to the line bc
    double s3 = dist(c, b);
    double ar=triarea(a,b,c);
    return(2.0*ar/s3);
}
void closestpt( PT p1, PT p2, PT p3, PT &r ){
// the closest point on the line p1->p2 to p3
    if( fabs( triarea( p1, p2, p3 ) ) < EPS ){
        r = p3; return; 
    }
    PT v = p2-p1;
    v.normalize();
    double pr; // inner product
    pr = (p3.y-p1.y)*v.y + (p3.x-p1.x)*v.x;
    r = p1+v*pr;
}
int hcenter( PT p1, PT p2, PT p3, PT& r ){
// point generated by altitudes
    if( triarea( p1, p2, p3 ) < EPS ) return -1;
    PT a1, a2;
    closestpt( p2, p3, p1, a1 );
    closestpt( p1, p3, p2, a2 );
    intersection( p1, a1, p2, a2, r );
    return 0;
}
int center( PT p1, PT p2, PT p3, PT& r ){
// point generated by circumscribed circle
    if( triarea( p1, p2, p3 ) < EPS ) return -1;
    PT a1, a2, b1, b2;
    a1 = (p2+p3)*0.5;
    a2 = (p1+p3)*0.5;
    b1.x = a1.x - (p3.y-p2.y);
    b1.y = a1.y + (p3.x-p2.x);
    b2.x = a2.x - (p3.y-p1.y);
    b2.y = a2.y + (p3.x-p1.x);
    intersection( a1, b1, a2, b2, r );
    return 0;
}
int pAndSeg(PT& p1, PT& p2, PT& p){
// the relation of the point p and the segment p1->p2.
// 1 if point is on the segment; 0 if not on the line; -1 if on the line but not on the segment
    double s=triarea(p, p1, p2);
    if(s>EPS) return(0);
    double sg=(p.x-p1.x)*(p.x-p2.x);
    if(sg>EPS) return(-1);
    sg=(p.y-p1.y)*(p.y-p2.y);
    if(sg>EPS) return(-1);
    return(1);
}
int lineAndCircle(PT& oo, double r, PT& p1, PT& p2, PT& r1, PT& r2){
// returns -1 if there is no intersection
// returns 1 if there is only one intersection
    PT m;
    closestpt(p1,p2,oo,m);
    PT v = p2-p1;
    v.normalize();
    double r0=dist(oo, m);
    if(r0>r+EPS) return -1;
    if(fabs(r0-r)<EPS)
    {
    r1=r2=m;
    return 1;
    }
    double dd = sqrt(r*r-r0*r0);
    r1 = m-v*dd; r2 = m+v*dd;
    return 0;
}
